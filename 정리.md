###### webpack
#### entry
웹 자원을 변환하기 위한 최초의 진입점
전반적인 파일구조나 내용을 넣어줘야함

#### output
번들링한 결과물의 파일경로
"filename" 옵션으로 결과물의 이름을 지정할 수 있음
[name] : 기존 파일명과 같은이름으로 지정
[hash] : 결과물에 고유의 해쉬값을 붙임
"path" 옵션으로 결과물의 경로를 지정할 수 있음

#### loader
자바스크립트가 아닌 웹자원들을 변환할 때 사용 (css, vue, png 등등)
기본적인 형태
module: {
  rules: [
    {
      test: /\.vue$/,
      use: 'vue-loader'
    }
  ]
}

rules배열내부에 loader를 지정할 파일들과 로더를 적음
test : 로더를 지정할 파일유형 (정규표현식 사용)
use : 사용할 로더를 적음

#### plugin
로더를 적용한 결과물의 형태를 바꿔줌
ex) vue플러그인 적용
plugins: [
  new VueLoaderPlugin(),
],

================================================================================================================================
###### login
#### passport
전략이라는단어를 이용해서 여러가지 인증전략을 사용하고 있음
그중에서 로그인에 적합한 local전략 ( id, pw 사용 인증 )을 사용함
인증순서
1. app에서 localStrategy, passport.initialize(), passport.session() 등록
2. 클라이언트에서 로그인 신호를 보냄
3. passport.authenticate('local', callback)에서 local까지만 보고
4. app에서 등록한 localStrategy의 local을 찾아감
5. req.body에 들어있는 id, pw를 이용해서 사용자인증을함
6. 각 분기처리를 해서 done의 두번째인자에 로그인성공한 사용자의 정보를 넘겨줌
7. passport.authenticate의 콜백함수로 넘어감 (done이 콜백함수임)
8. passport.authenticate에서 처리후 req.login()호출
9. serializeUser호출됨 req.login인자가 매개변수로 들어감
10. done에서 전송한 값이 세션에 저장됨
11. 페이지 이동할 때 마다 deserializeUser() 호출되고 passport.sesison()이 실행되어 인자로 유저의 값이 들어옴
12. 결국 deserializeUser()호출됨으로 req.user에 유저정보가 저장됨

login전송 -> passport-local전략사용 -> 정의해둔 localStrategy이동 -> 각종 조건검사 (유저존재여부, db에러여부 등) -> done(passport.authenticate)호출
-> 전송받은 인자로 문제해결처리 -> 문제없으면 로그인성공이므로 req.login()호출 -> req.login()의 매개변수들이 serializeUser의 인자로 들어가서 호출됨
-> serializeUser의 done()의 두번째인자로 주는값이 passport.session()에 의해 저장됨 -> 다른페이지 이동할때마다 deserializeUser()호출되고 그로인해 req.user에 유저정보가 저장됨

#### vue-cookie
Vue.use(VueCookie)하면
this.$cookies로 접근가능하게됨
this.$cookies.isKey(key) : key에 해당하는 쿠키 존재하는지 여부 반환
this.$cookies.get(key) : key에 해당하는 쿠키값 반환

#### vuejs-jwt
Vue.use(VueJwt);
this.$jwt.decode(jwt) : jwt를 디코딩해서 객체로 반환해줌

#### this.$router
this.$router.push('url')과 <router-link to="url">은 정확하게 같은방식으로 페이지를 넘어감
.go(), .replace()도 가능

================================================================================================================================
###### sequelize
sequelize란 ORM으로 가상의 데이터베이스를 코드상에서 구현해서 가상의 데이터베이스와 실제 데이터베이스를 맵핑해서 가상의 데이터베이스를 변경해도 실제데이터베이스가 변경되도록 해주는것?
sequelize를 사용하면 기본적으로 제공해주는 기능들도 많으며 직접 SQL문을 사용하지않아도 형식을 정의해주면 자동적으로 SQL로 변환해주기때문에 편리함

#### 기본적인 형태
## index.js
const Sequelize = require('sequelize');
const env = process.env.NODE_ENV || 'development';
const config = require('../config/config.json')[env];
const User = require('./user.js');

const db = {};
const sequelize = new Sequelize(config.database, config.username, config.password, config);   // db와 node.js연결

db.sequelize = sequelize;

db.User = User;

db.User.init(db.sequelize);

db.User.associate(db);

module.exports = db;    // db객체에 sequelize, model모두 넣어두고 db를 require해서 편하게 사용

## model/user.js
const Sequelize = require("sequelize");

module.exports = class User extends Sequelize.Model {   // 약속된 구조이므로 구조는 변경하면안됨
  static init(sequelize){
    return super.init({     // 여기밑에 column들 정의
      identify: {
        type: Sequelize.STRING(20),
        allowNull: true,
        unique: true,
      },
    }, {
      sequelize,          // 요거안넣으면 오류남
      timestamps: true,   // createdAt, updatedAt, deleteAt 자동으로 넣어줄지
      paranoid: false,    // 삭제해도 데이터남겨둘지말지 deleteAt에 시간만 적어짐
      underscored: false, // 대문자 _  뭘로구분할지지정
      modelName: "User",  // sequelize에서 사용할 모델명
      tableName: "users", // 실제 DB에서 사용할 테이블명
      charset: "utf8",    // 한글가능..           밑에꺼랑 둘다 mb4붙이면 특수문자도 입력가능
      collate: "utf8_general_ci",   // charset과 같은의미인것같은데
    });
  }

  static associate(db){     // 테이블, 즉 모델간의 관계를 정의하는 부분
    // 유저와 채팅방 M : N
    db.User.belongsToMany(db.Room, { through: "UserRoom", foreignKey: "userId", targetKey: "id" });

    // 유저와 채팅 1 : N
    db.User.hasMany(db.Chatting, { foreignKey: "userId", targetKey: "id" });
  }
}
## 관계정의
1. belongsTo : 포함
2. hasMany : 가짐
3. belongsToMany : 가지고 포함됨

일단 관계에서는 1 : 1, 1 : N, N : M 관계들이 있음
1. 1 : 1
둘다 belognsTo로 연결하면됨
2. 1 : N
많이가지는놈 hasMany
속하는놈 belongsTo
3. N : M
둘다 belongsToMany

한글그대로 해석하면됨
여기서 알아야할것
foreignKey : 참조키를 가질 테이블에 생성될 column명을 정하는것
참조키를 가질 테이블이란 1 : N에서 N쪽 즉, belongsTo로 지정한곳에 참조키가 생성됨

targetKey : 참조당하는쪽의 column명을 정해줘야함
참조당하는거니까 unique한걸로 지정해주는것이 맞음 (본인임을 증명할 수 있는 식별자.. 주민번호같은거. 중복될 수 없는것)

through : (N : M)관계일 때는 필연적으로 새로운 테이블이 생길 수 밖에 없음
ex) 전부 id만 있다고 가정하고
user     room       user_room
  1       1           1    2 
  2       2           1    3
  3       3           3    1
  4       4           4    1
user 1이 room2를 참조한다고 했을때 1 : N 관계라면
room에 userId를 넣어서 참조하면 되겠지만 N : M이라면
user1에서도 room2를 참조해야하고
room2에서도 user1을 참조해야하는데 새로운테이블을 만들지않고서는 구현할 수 없음 (사실 아직 제대로 이해못하겠음)
따라서 새로운 테이블이 생성되며 그테이블 이름은 자동적으로 두개의 테이블명이 합쳐지는데
원하는대로 정의하고 싶을 때 through : "테이블명"을 하면 원하는 테이블명이 생성됨
as : 이름 바꾸는것 기본적으로 제공되는 이름말고 다른이름으로 바꿔서 사용함
주로 자기가 자기자신과 (N : M)일경우 사용함

위와같이 관계정의를 하고나면 자동적으로
get, set, add, remove메서드가 생성됨
ex) const user = await User.findOnd({ where: { id: 1 } });
user.getComments();                  // 유저와 연동된 comment들을 가져옴
user.setComments(comment의 배열);     // 유저와 연동된 comment들을 수정
user.addComment(comment);            // 유저와 연동된 comment들을 하나추가함
user.addComments(comment의 배열);     // 유저와 연동된 comment들을 추가함
user.removeComments(comment의 배열);  // 유저와 연동된 comment들을 수정

================================================================================================================================
###### socket.io
실시간 채팅기능을 구현할 때 사용하기 용이하도록 정의된 패키지

#### 기본연결방식
const app = express();
const server = app.listen(~~);
const io = new SocketIO.Server(server);

위같은 형식으로 io생성하면됨
현재 io의 옵션값으로 path말고도 이것저것붙여줬는데 이유는 모르겠으나 에러가떠서 구글링해서 찾은걸 그냥 적어줬음 (이유는 나중에 찾겠음.. 현재는 구현하는데 집중)

#### 접속 및 이벤트연결
io.on("connetion", socket => { ... });
소켓에 연결했을 때 콜백함수 실행 (인수로 socket객체가 들어오도록 약속됨)

socket.on("이벤트", 콜백);
위같은 형식으로 구현하면됨

1. disconnecting : 접속해제시 실행 (disconnect도 있는데 이거는 soeket.id를 얻을 수 없음)
2. error : 에러발생시 실행됨 콜백인수에 error객체전송됨

클라이언트에서 
socket.emin("이벤트명", 변수1, 변수2 ..); 형식으로 전송하면
서버에서 미리정의해둔
socket.on("이벤트명", (변수1, 변수2 ...) => { ... }); 형식으로 받아서 대응할 수 있음
서버에서 클라로 전송할 때도 같은방식으로 하면됨

socket.io에는 namespace와 room이라는것이 있는데
#### namespace
namespace는 현재코드에서 사용하지않아서 간단하게 정리함
일단 namespace > room > socket 처럼 관계를 생각하면되고 ... 기본 네임스페이스는 '/'로 알고있음
서버측)
let nsp = io.of('/test');    // /test인 네임스페이스 생성
nsp.on("이벤트명", 콜백);     // /test인 네임스페이스로 이벤트전송
클라측)
let nsp = io('/test');

#### room
기본적으로 join과 leave로 방에 출입을 할 수 있음 (방이름은 아무거나 가능)
socket.join("방이름");
socket.leave("방이름");

원하는 방에 값을 주는방법은
io.to("방이름").emit("이벤트명", "값");

자기자신제외한 모두에게 전송 (io -> socket.broadcast)
socket.broadcast.to(socket.roomName).emit("system", `${socket.nickname}님이 채팅방에 퇴장하셨습니다.`);

받는방법이 없는거는
클라 -> 서버 -> 방검색 -> 방에 값전달 같은형식이라
어차피 주고받을때 서버로 전송할 수 밖에 없음
서버에서 각각의 방으로 데이터를 전송하는것


================================================================================================================================

지금 문제가 하나있는게
소켓으로 방을 생성해서 DB에 추가하는데
DB에 추가하기전에 다른코드를 실행해서 화면에 데이터가 붙지를 않음
await socket.emit()뭐 이런코드를 써도 기다려주지를않아서 해결방법을 찾아야함