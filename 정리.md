###### webpack
#### entry
웹 자원을 변환하기 위한 최초의 진입점
전반적인 파일구조나 내용을 넣어줘야함

#### output
번들링한 결과물의 파일경로
"filename" 옵션으로 결과물의 이름을 지정할 수 있음
[name] : 기존 파일명과 같은이름으로 지정
[hash] : 결과물에 고유의 해쉬값을 붙임
"path" 옵션으로 결과물의 경로를 지정할 수 있음

#### loader
자바스크립트가 아닌 웹자원들을 변환할 때 사용 (css, vue, png 등등)
기본적인 형태
module: {
  rules: [
    {
      test: /\.vue$/,
      use: 'vue-loader'
    }
  ]
}

rules배열내부에 loader를 지정할 파일들과 로더를 적음
test : 로더를 지정할 파일유형 (정규표현식 사용)
use : 사용할 로더를 적음

#### plugin
로더를 적용한 결과물의 형태를 바꿔줌
ex) vue플러그인 적용
plugins: [
  new VueLoaderPlugin(),
],

###### login
#### passport
전략이라는단어를 이용해서 여러가지 인증전략을 사용하고 있음
그중에서 로그인에 적합한 local전략 ( id, pw 사용 인증 )을 사용함
인증순서
1. app에서 localStrategy, passport.initialize(), passport.session() 등록
2. 클라이언트에서 로그인 신호를 보냄
3. passport.authenticate('local', callback)에서 local까지만 보고
4. app에서 등록한 localStrategy의 local을 찾아감
5. req.body에 들어있는 id, pw를 이용해서 사용자인증을함
6. 각 분기처리를 해서 done의 두번째인자에 로그인성공한 사용자의 정보를 넘겨줌
7. passport.authenticate의 콜백함수로 넘어감 (done이 콜백함수임)
8. passport.authenticate에서 처리후 req.login()호출
9. serializeUser호출됨 req.login인자가 매개변수로 들어감
10. done에서 전송한 값이 세션에 저장됨
11. 페이지 이동할 때 마다 deserializeUser() 호출되고 passport.sesison()이 실행되어 인자로 유저의 값이 들어옴
12. 결국 deserializeUser()호출됨으로 req.user에 유저정보가 저장됨

login전송 -> passport-local전략사용 -> 정의해둔 localStrategy이동 -> 각종 조건검사 (유저존재여부, db에러여부 등) -> done(passport.authenticate)호출
-> 전송받은 인자로 문제해결처리 -> 문제없으면 로그인성공이므로 req.login()호출 -> req.login()의 매개변수들이 serializeUser의 인자로 들어가서 호출됨
-> serializeUser의 done()의 두번째인자로 주는값이 passport.session()에 의해 저장됨 -> 다른페이지 이동할때마다 deserializeUser()호출되고 그로인해 req.user에 유저정보가 저장됨

#### vue-cookie
Vue.use(VueCookie)하면
this.$cookies로 접근가능하게됨
this.$cookies.isKey(key) : key에 해당하는 쿠키 존재하는지 여부 반환
this.$cookies.get(key) : key에 해당하는 쿠키값 반환

#### vuejs-jwt
Vue.use(VueJwt);
this.$jwt.decode(jwt) : jwt를 디코딩해서 객체로 반환해줌

#### this.$router
this.$router.push('url')과 <router-link to="url">은 정확하게 같은방식으로 페이지를 넘어감
.go(), .replace()도 가능