###### 인터넷 프로토콜 스택 4계층
애플리케이션계층 - HTTP, FTP
전송계층 - TCP, UDP
인터넷계층 - IP
네트워크 인터페이스 계층 - LAN장비

┌----(IP패킷)---------------------------------------------------------------┐
│     출발지 IP, 목적지 IP 등등                                              │ 
│   ┌--------(TCP공간)---------------------------------------------------┐  │ 
│   │   출발지port, 목적지port, 전송제어정보, 순서정보, 검증정보 등등        │  │  
│   │  ┌--------(전송데이터)-----------------------------------------┐    │  │ 
│   │  │                                                            │    │  │ 
│   │  │                                                            │    │  │ 
│   │  └------------------------------------------------------------┘    │  │ 
│   └--------------------------------------------------------------------┘  │ 
└---------------------------------------------------------------------------┘

=================================================================================================
###### IP
인터넷으로 통신하기위해서는 각자의 IP가 있어야함
client -> node1 -> node2 ... -> server
client에서 server로 신호를 보내거나 뭔가를 전송할 때는 반드시 각자의 IP가 필요함
전송보내는놈IP, 전송받는놈 IP, 전송데이터를 패킷이라는 단위로 묶어서 전송함
## IP만으로 전송할 때의 문제점
1. 패캣이 전송중에 손실될 수 있음 ( 전송중간 node가 오류나는경우 )
2. 전송될 서버가 종료되어있을 수 있음
3. 패킷들의 전송순서가 안맞을 수 있음

=================================================================================================
###### TCP
IP의 문제점을 보완하기위해 사용해주는 전송 제어 프로토콜
출발 port, 도착 port, 전송제어정보, 순서정보, 검증정보등을 가짐
## 1. 연결지향 - TCP 3 way handshake
client ---> server (SYN)          client가 server에게 접속요청보냄
client <--- server (ACK + SYN)    server가 요청수락과 동시에 접속요청을 보냄
client ---> server (ACK)          client가 요청수락함으로서 client와 server가 연결됨
SYN : 접속 요청
ACK : 요청 수락
## 3. 순서 보장
순서정보에 맞지않게 패킷이 전송될경우 처음부터다시 순서에 맞게 전송됨

=================================================================================================
###### UCP
연결지향, 데이터전달보증, 순서보장을 해주지않음
IP에서 port와 체크섬정도만 추가됨

=================================================================================================
###### PORT
같은 IP내에서 process를 구분하는데 사용
ex) 게임을 하면서 음악을 듣는경우에
clinet에서 게임에 요청을 보내고, 음악에도 요청을 보내야하며
게임과 음악에서 각각 client의 요청에 대한 응답을 보낼때 clinet입장에서 어느것이 음악이고 게임인지 모호하기때문에
port라는 개념을 만들어서 게임은 99번port로 지정하고 음악은 100번port로 지정해서 데이터가 섞이지 않음
애초에 client에서 요청을 보낼 때 port번호를 같이 보내기때문에 server측에서 응답받은 TCP를 이용해서 응답보낼 때 port로 사용함

=================================================================================================
###### DNS
Domain Name System
IP주소는 기억하기 어렵고 변경될 수 있기때문에
IP에 해당하는 Domain을 DNS서버에 IP와 Domain을 맵핑해놓고 사용

=================================================================================================
###### URL, URN, URI
URI : 리소스식별
URL : 리소스의 위치
URN : 리소스의 이름 ( 거의 사용하지 않음 )
URI = URL + URN
URL구조 : scheme://[userinfo@]host[:port][/path][?query][#fragment]

=================================================================================================
###### HTTP요청메시지
전송순서
1. 웹브라우저에서 HTTP메시지 생성
2. socket라이브러리를 통해 TCP/IP에 HTTP메시지 전송
3. TCP/IP에서 패킷생성
4. LAN장비로 전송
5. LAN장비에서 인터넷을 통해서 서버로 전송

=================================================================================================
###### 무상태프로토콜
server가 client의 상태를 보존하지않음

=================================================================================================
###### 비연결성


=================================================================================================
###### HTTP메시지


=================================================================================================
###### HTTP메소드
### 1. Get
리소스조회
안전, 멱등, 캐시
### 2. Post
리소스생성
캐시
### 3. Put
리소스완전대체
멱등
### 4. Patch
리소스부분수정
멱등, 캐시
### 5. Delete
리소스삭제
멱등

안전 : 호출함으로서 원본데이터에는 변화없음
멱등 : 몇번호출하든 결과는 항상같음

=================================================================================================
###### client -> server 데이터전송방법
### 1. 정적 데이터 조회

### 2. 동적 데이터 조회
Get / 쿼리파라미터를 이용함

### 3. Form 데이터 전송
Content-Type: application/x-www-form-urlencoded
( name=Kim&age=20 ) 같은 형태로 넘어감
폼 전송을 누르면 위와 같은 형식으로 HTTP메시지가 생성되고 전송됨

### 4. HTTP API 데이터 전송
AJAX통신을 이용해서 데이터 전송
Content-Type: application/json

=================================================================================================
###### HTTP API설계 예시
항상 리소스를 먼저 생각해야함
최대한 리소스 + 메소드조합으로 설계해야함
"게시판을 생성한다"에서 리소스는 게시판, 메소드는 생성
원칙적으로는 리소스 + 메소드 조합으로 설계하는것이 맞지만 이게 애해한경우가 있음
그때 컨트롤uri를 사용하면됨 ex)Post / goods/{id}/delivery
### 회원관리시스템
1. 회원목록 /members => GET
2. 회원등록 /members => POST
3. 회원조회 /members/{id} => GET
4. 회원수정 /members/{id} => PUT, PATCH, POST
5. 회원삭제 /members/{id} => DELETE
### ?
document :    
collection : 서버가 관리하는 리소스
store : 클라이언트가 관리하는 리소스
controller : 위 3개로 해결하기 힘든 프로세스

=================================================================================================
###### 상태코드
### 1XX
요청이 수신되어 처리중
### 2XX
요청정상처리
ex)
1. 200 OK
2. 201 Created
3. 202 Accepted ( 요청접수완료, 처리는 미완료 )
4. 204 Not Content ( 요청수행, 페이로드본문에 보낼데이터없음 )
### 3XX
요청완료하려면 추가 행동 필요
## 리다이렉션
# 영구 리다이렉션
# 일시 리다이렉션
# 특수 리다이렉션
1. 301 Modved Premanently ( 요청메소드 get변경, 본문제거 후 리다이렉션 )
2. 308 Permanent Redirect
3. 302 Found ( 요청메소드 get변경, 본문제거 )
4. 307 Temporary Redirect ( 요청메소드 변경X )
5. 303 See Other ( 요청메소드 get변경 )
6. 304 Not Modified ( 캐시목적으로 사용 )
### 4XX
클라이언트 오류
1. 401 Unauthorized
2. 403 Forbidden ( 요청은 이해했지만 승인거부 )
3. 404 Not Found
### 5XX
서버 오류
1. 500 Internal Server Error ( 대표적인 서버에러임을 의미 )
2. 503 Service Unavailable ( 일시적 서비스이용불가 )

=================================================================================================
###### HTTP Header
### 1. General Header
메시지 전체에 적용되는 정보
### 2. Request Header
요청 정보
### 3. Response Header
응답 정보
### 4. Entity Header
엔티티 바디의 정보 ( Content-type: text/html; charset=utf-8 )
Entity Body : 전달된 데이터

=================================================================================================
###### content협상
### Accept-Language
브라우저가 요청하는 언어로 전송부탁 ( en, ko )
ex) Accet-Language: ko-KR, ko;q=0.9, en-US;q=0.8, en;q=0.7
위와 같이 있을때 q는 Quality Value의 축약어
q => 1 ~ 0.1사이의 값을 가지며 생략시 1임
높을수록 우선순위가 높아지고 서버측에서 제공하는 언어중 가장높은 우선순위의 언어로 제공해줌
### Accept
클라이언트가 선호하는 미디어 타입전달
ex) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif
### Accept-Encoding
클라이언트가 선호하는 압축 인코딩
### Accept-Charset
클라이언트가 선호하는 문자 인코딩

=================================================================================================
###### content표현
Content-Type : 파일정보
Content-Encoding : 압축방법
Content-Lenguage : 자연언어
Content-Length : 길이
Transfer-Encoding : 분할전송방식 ( 각각의 chunked로 나눠서 클라이언트에게 전송함 )
Range or Content-Range: bytes=1001-2000 ( 정해진만큼만 전송받기 )

=================================================================================================
###### 일반정보성 헤더
From: 유저에이전트의 이메일 정보
referer: 이전 웹페이지 주소
User-Agent: 클라이언트의 애플리케이션 정보
Server: 요청을 처리하는 Origin서버의 소프트웨어정보
Date: 접속시간

=================================================================================================
###### 특별한 헤더
Host: 요청한 호스트 정보 ( 하나의 서버에서 여러개의 도메인을 이용하는 경우 구분하기 위함 *필수 )
Location: 300대의 Location헤더가 존재하면 자동 Redirect
Allow: 405에서 접근가능한 메서드를 명시해줘야함
Retry-After: 503에서 다음요청까지 기다려야하는시간명시

=================================================================================================
###### 인증 헤더
Authorization: 클라이언트의 인증정보를 서버에 전달
WWW-Authenticate: 401일경우 리소스 접근시 필요한 인증방법 정의

=================================================================================================
###### 쿠키
Set-Cookie: 서버에서 클라이언트로 쿠키 전달
Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP요청시 서버로 전달
세션쿠키 : 브라우저종료할 때 까지 유지
expires(만료일)
max-age(지정시간)
domain(지정된 도메인에서만 사용)
path(지정된 path하위경로에서만 쿠키접근가능)
Secure: HTTPS인경우에만 쿠키전송
HttpOnly: JS로 접근불가 (XSS공격방지)
SameSite: 요청도메인과 쿠키설정도메인이 같은경우에만 쿠키전송 (XSRF공격방지)

=================================================================================================
###### 캐쉬
### cache-control: max-age=60
60초동안 해당 오브젝트를 브라우저의 캐쉬저장소에 저장해둔다.
단. 지정시간초과시 재요청함
### 검증헤더
last-modified: Thu, 04 Jun 2020 07:19:23 GMT      (서버측)
if-modified-since: Thu, 04 Jun 2020 07:19:26 GMT  (클라 -> 서버로 전송될 헤더)
브라우저에서 캐쉬가 기간이 지났을경우 서버와 클라의 검증헤더를 비교해서 만약 검증헤더가 일치하면
서버측에서 304(Not Modified)인 헤더만 전송해서 브라우저캐쉬저장소의 오브젝트를 다시 재사용함
### ETag, If-None-Match
캐시용 데이터에 고유한 이름을 지정함
ETag가 일치하면 304헤더만전송하고 (If-None-Match)
불일치하면 전체 데이터를 다시전송
### cache-control
cache-control: max-age:;   // 일정기간유지
cache-control: no-cache;   // 데이터캐쉬해도되지만 항상 원서버에 검증하고 사용
cache-control: no-store;   // 저장X
cache-control: public;     // public캐쉬서버에 저장해도 되는 데이터
cache-control: private;    // private캐쉬서버에만 저장해야하는 데이터 (해당 사용자만을 위한 데이터)
cache-control: s-maxage:;  // 프록시캐쉬에만 적용되는 max-age
Age: 60;    // 캐쉬가 오리진서버에 저장되는 시간
Expires:;   // 캐쉬 만료일 지정 (우선순위낮음)

=================================================================================================
###### 
RFC 7230 ~ 7235로 스펙봐야함